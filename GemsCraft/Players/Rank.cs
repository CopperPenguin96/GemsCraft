using GemBlocks.Worlds;
using GemsCraft.AppSystem.Exceptions;
using GemsCraft.AppSystem.Logging;
using GemsCraft.Utils;
using JetBrains.Annotations;
using LightJson;
using System;
using System.Collections.Generic;
using System.Linq;
using GemsCraft.ChatSystem;

namespace GemsCraft.Players
{
    public sealed class Rank: IClassy, IComparable<Rank>
    {
        /// <summary>
        /// Rank color mode. Should not be left blank.
        /// </summary>
        [NotNull]
        public string Color { get; set; }

        [NotNull]
        public string Prefix { get; set; }

        /// <summary>
        /// Can other players see this player?
        /// Set by using hide and unhide commands
        /// </summary>
        public bool IsHidden = false;

        /// <summary>
        /// Rank's displayed name.
        /// Use rank.FullName instead for serializing
        /// </summary>
        [NotNull]
        public string Name { get; internal set; }

        /// <summary>
        /// Unique rank ID. Generated by Rank.GenerateID(). Assigned once at creation.
        /// Used to preserve comptability in case a rank gets renamed.
        /// </summary>
        [NotNull]
        public string ID { get; private set; }

        /// <summary>
        /// Set of permissions given to this rank. Use Rank.Can() to access
        /// </summary>
        [NotNull]
        public bool[] Permissions { get; private set; }

        /// <summary>
        /// Whether players of this rank are allowed to remove restrictions that affect themselves.
        /// Affects /WMain, /WAccess, /WBuild, /ZAdd, /ZEdit, and /ZRemove.
        /// </summary>
        public bool AllowSecurityCircumvention;

        public int CopySlots = 2;
        public int FillImit = 32;
        public int DrawLimit;

        public int IdleKickTimer;
        public int AntiGriefBlocks;
        public int AntiGriefSeconds;

        public bool ReservedSlot;

        /// <summary>
        /// Rank's relative index on the hierarchy.
        /// Index of the top rank is always 0 and goes up as ranks go down.
        /// Lowest rank will be the highest number.
        /// </summary>
        public int Index;

        [CanBeNull]
        public Rank NextRankUp { get; internal set; }

        [CanBeNull]
        public Rank NextRankDown { get; internal set; }

        [CanBeNull]
        public World MainWorld { get; set; }

        #region Constructors

        public Rank()
        {
            Permissions = new bool[Enum.GetValues(typeof(Permission)).Length];
            PermissionLimits = new Rank[Permissions.Length];
            PermissionLimitStrings = new string[Permissions.Length];
            Color = ChatColor.White;
            Prefix = "";
        }

        public Rank([NotNull] string name, [NotNull] string id): this()
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            ID = id ?? throw new ArgumentNullException(nameof(id));
            FullName = Name + "#" + ID;
        }

        public Rank([NotNull] JsonObject json) : this()
        {
            if (json == null) throw new ArgumentNullException(nameof(json));

            // Name
            string name = json["name"];
            if (name == null)
            {
                throw new RankDefinitionException(null, "Rank definition with no name was ignored.");
            }

            if (!IsValidRankName(name.Trim()))
            {
                throw new RankDefinitionException(Name,
                    $"Invalid name specified for rank \"{Name}\". " +
                    "Rank names can only contain letters, digits, and underscores. " +
                    "Rank defintion was ignored.");
            }
            else
            {
                // duplicate Name check is done in RankManager.AddRank()
                Name = name.Trim();
            }

            // ID
            string id = json["id"];
            if (id == null)
            {
                ID = RankManager.GenerateID();
                Logger.Log(LogType.Warning,
                    $"Rank({Name}): No ID specified; issued a new unique ID: {ID}");
            }
            else if (!IsValidID(id.Trim()))
            {
                ID = RankManager.GenerateID();
                Logger.Log(LogType.Warning,
                    $"Rank({Name}): Invalid ID specified (must be alphanumeric and exactly 16 characters long); " +
                    $"issued a new unique ID: {ID}");
            }
            else
            {
                ID = id.Trim();
                // duplicate ID check is done in RankManager.AddRank()
            }

            FullName = Name + "#" + ID;

            // Color (optional)
            string color = json["color"];
            if (color != null)
            {
                string cColor = ChatColor.Parse(color);
                if (cColor == null)
                {
                    Logger.Log(LogType.Warning,
                        $"Rank({Name}): Could not parse rank color. Assuming default.");
                    Color = ChatColor.White;
                }
                else
                {
                    Color = cColor;
                }
            }
            else
            {
                Color = ChatColor.White;
            }

            // Prefix (Optional)
            string prefix = json["prefix"];
            if (prefix != null)
            {
                if (IsValidPrefix(prefix))
                {
                    Prefix = prefix;
                }
                else
                {
                    Logger.Log(LogType.Warning,
                        $"Rank({Name}): Invalid prefix format. Expecting 1 character.");
                }
            }

            // AntiGrief block limit (assuming unlimited if not given)
            int value;
            int agBlocks = json["antiGriefBlocks"];
            int agSeconds = json["antiGriefSeconds"];
            if (int.TryParse(json["antiGriefBlocks"], out value))
            {
                if (value >= 0 && value < 1000)
                {
                    AntiGriefBlocks = value;
                }
                else
                {
                    Logger.Log(LogType.Warning,
                        $"Rank({Name}): Value for antiGriefBlocks is not within " +
                        $"valid range (0-1000). Assuming default ({AntiGriefBlocks})");
                }
            }

            if (int.TryParse(json["antiGriefSeconds"], out value))
            {
                if (value >= 0 && value < 100)
                {
                    AntiGriefSeconds = value;
                }
                else
                {
                    Logger.Log(LogType.Warning,
                        $"Rank({Name}): Value for antiGriefSeconds is not within valid range (0-100). Assuming default ({AntiGriefSeconds}).");
                }
            }
            else
            {
                Logger.Log(LogType.Warning,
                    $"Rank({Name}): Could not parse the value for antiGriefSeconds. Assuming default ({AntiGriefSeconds}).");
            }

            // Draw command limit, in number-of-blocks (assuming unlimited if not given)
            if (int.TryParse(json["drawLimit"], out value))
            {
                if (value >= 0 && value < 100000000)
                {
                    DrawLimit = value;
                }
                else
                {
                    Logger.Log(LogType.Warning,
                        "Rank({0}): Value for drawLimit is not within valid range (0-100000000). Assuming default ({1}).",
                        Name, DrawLimit);
                }
            }
            else
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse the value for drawLimit. Assuming default ({1}).",
                    Name, DrawLimit);
            }

            // Idle kick timer, in minutes. (assuming 'never' if not given)
            if (!int.TryParse(json["idleKickAfter"], out IdleKickTimer))
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse the value for idleKickAfter. Assuming 0 (never).",
                    Name);
                IdleKickTimer = 0;
            }
            else
            {
                IdleKickTimer = 0;
            }

            // Reserved slot. (assuming 'no' if not given)
            if (!bool.TryParse(json["reserveSlot"], out ReservedSlot))
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse value for reserveSlot. Assuming \"false\".", Name);
                ReservedSlot = false;
            }
            else
            {
                ReservedSlot = false;
            }

            // Security circumvention (assuming 'no' if not given)
            if (!bool.TryParse(json["allowSecurityCircumvention"], out AllowSecurityCircumvention))
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse the value for allowSecurityCircumvention. Assuming \"false\".",
                    Name);
                AllowSecurityCircumvention = false;
            }
            else
            {
                AllowSecurityCircumvention = false;
            }

            // Copy slots (assuming default 2 if not given)
            if (int.TryParse(json["copySlots"], out value))
            {
                if (value > 0 && value < 256)
                {
                    CopySlots = value;
                }
                else
                {
                    Logger.Log(LogType.Warning,
                        "Rank({0}): Value for copySlots is not within valid range (1-255). Assuming default ({1}).",
                        Name, CopySlots);
                }
            }
            else
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse the value for copySlots. Assuming default ({1}).",
                    Name, CopySlots);
            }

            // Fill limit (assuming default 32 if not given)
            if (int.TryParse(json["fillLimit"], out value))
            {
                if (value < 1)
                {
                    Logger.Log(LogType.Warning,
                        "Rank({0}): Value for fillLimit may not be negative. Assuming default ({1}).",
                        Name, FillLimit);
                }
                else if (value > 2048)
                {
                    FillLimit = 2048;
                }
                else
                {
                    FillLimit = value;
                }
            }
            else
            {
                Logger.Log(LogType.Warning,
                    "Rank({0}): Could not parse the value for fillLimit. Assuming default ({1}).",
                    Name, FillLimit);
            }

            // Permissions
            JsonArray foundPerms = json["permissions"];
            for (int i = 0; i < Enum.GetValues(typeof(Permission)).Length; i++)
            {
                PermissionJsonObject pObj = (PermissionJsonObject) foundPerms[i].AsObject;
                if (pObj.PermissionValue != i) continue;
                Permissions[i] = true;
                string val = pObj.PerissionLimitString;
                if (!val.StartsWith("max:")) continue;
                const int startVal = 5;
                string item = val.Substring(startVal);
                PermissionLimitStrings[i] = item;
            }

            // Check consistency of ban permissions

        }

        public class PermissionJsonObject
        {
            public int PermissionValue { get; set; }
            public string PerissionLimitString { get; set; }
        }

        #endregion

        #region Tags

        private const string NameTag = "name";
        private const string IDTag = "id";
        private const string ColorTag = "color";
        private const string PrefixTag = "prefix";
        private const string AgBlocksTag = "antiGriefBlocks";
        private const string AgSecondsTag = "antiGriefSeconds";
        private const string DrawLimitTag = "drawLimit";
        private const string IdleKickTag = "idleKickAfter";
        private const string ReserveTag = "reserveSlot";
        private const string SecurityCircTag = "allowSecurityCircumvention";
        private const string CopyTag = "copySlots";
        private const string FillTag = "fillLimit";
        private const string PermissionTag = "Permissions";

        #endregion

        public JsonObject Serialize()
        {
            JsonObject obj = new JsonObject {{NameTag, Name}, {IDTag, ID}};

            string colorName = ChatColor.GetName(Color);
            if (colorName != null)
            {
                obj.Add(ColorTag, colorName);
            }

            if (Prefix.Length > 0) obj.Add(PrefixTag, Prefix);
            obj.Add(AgBlocksTag, AntiGriefBlocks);
            obj.Add(AgSecondsTag, AntiGriefSeconds);

            if (DrawLimit > 0) obj.Add(DrawLimitTag, DrawLimit);
            if (IdleKickTimer > 0) obj.Add(IdleKickTag, IdleKickTimer);
            if (ReservedSlot) obj.Add(ReserveTag, ReservedSlot);
            if (AllowSecurityCircumvention) obj.Add(SecurityCircTag, AllowSecurityCircumvention);

            obj.Add(CopyTag, CopySlots);
            obj.Add(FillTag, FillLimit);
            List<PermissionJsonObject> perms = new List<PermissionJsonObject>();
            for (int i = 0; i < Enum.GetValues(typeof(Permission)).Length; i++)
            {
                PermissionJsonObject pt = new PermissionJsonObject();
                if (Permissions[i])
                {
                    pt.PermissionValue = i;

                    if (PermissionLimits[i] != null)
                    {
                        pt.PerissionLimitString = "max: " + GetLimit((Permission) i).FullName;
                    }
                }

                perms.Add(pt);
            }

            return obj;
        }

        #region Rank Comparison Operators

        public int CompareTo([NotNull] Rank other)
        {
            if (other == null) throw new ArgumentNullException(nameof(other));
            return other.Index - Index;
        }

        public static bool operator >(Rank a, Rank b)
        {
            return a.Index < b.Index;
        }

        public static bool operator <(Rank a, Rank b)
        {
            return a.Index > b.Index;
        }

        public static bool operator >=(Rank a, Rank b)
        {
            return a.Index <= b.Index;
        }

        public static bool operator <=(Rank a, Rank b)
        {
            return a.Index >= b.Index;
        }

        #endregion

        #region Permissions

        public bool Can(Permission permission)
        {
            return Permissions[(int) permission];
        }

        public bool Can(Permission permission, [NotNull] Rank other)
        {
            if (other == null) throw new ArgumentNullException(nameof(other));
            return Permissions[(int) permission] && GetLimit(permission) >= other;
        }

        public bool CanSee([NotNull] Rank other)
        {
            if (other == null) throw new ArgumentNullException(nameof(other));
            return this > other.GetLimit(Permission.Hide);
        }

        #endregion

        #region Permission Limits

        public Rank[] PermissionLimits { get; private set; }

        public readonly string[] PermissionLimitStrings;

        public Rank GetLimit(Permission permission)
        {
            return PermissionLimits[(int) permission] ?? this;
        }

        public void SetLimit(Permission permission, [CanBeNull] Rank limit)
        {
            PermissionLimits[(int) permission] = limit;
        }

        public void ResetLimit(Permission permission)
        {
            SetLimit(permission, null);
        }

        public int GetLimitIndex(Permission permission)
        {
            if (PermissionLimits[(int) permission] == null)
            {
                return 0;
            }
            else
            {
                return PermissionLimits[(int) permission].Index + 1;
            }
        }
         
        #endregion

        #region Validation

        public static bool IsValidRankName([NotNull] string rankName)
        {
            if (rankName == null) throw new ArgumentNullException(nameof(rankName));
            if (rankName.Length < 1 || rankName.Length > 16) return false;

            return rankName.All(ch => ch >= '0' && (ch <= '9' 
                                                    || ch >= 'A') && (ch <= 'Z' || ch >= '_') && (ch <= '_' || ch >= 'a') && ch <= 'z');
        }

        public static bool IsValidID([NotNull] string id)
        {
            if (id == null) throw new ArgumentNullException(nameof(id));
            return id.Length == 16 
                   && id.All(ch => ch >= '0' && (ch <= '9' || ch >= 'A') && (ch <= 'Z' || ch >= 'a') && ch <= 'z');
        }

        public static bool IsValidPrefix([NotNull] string prefix)
        {
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Length == 0) return true;
            if (prefix.Length > 1) return false;
            
        }
        #endregion
    }
}
